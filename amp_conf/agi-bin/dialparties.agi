#!/usr/bin/perl -w
#
# Copyright (C) 2003 Zac Sprackett <zsprackett-asterisk@sprackett.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# Amended by Coalescent Systems Inc. Sept, 2004
# to include support for DND, Call Waiting, and CF to external trunk
# info@coalescentsystems.ca

use Asterisk::AGI;
use Net::Telnet ();

# Minor modifications to assist with Dependancy checking, automatically
# parse required information from /etc/amportal.conf, and slightly more
# descriptive error reporting by Rob Thomas <xrobau@gmail.com> 
# 18th Sep 2005

if (eval "require Asterisk::AGI;") {
        use Asterisk::AGI;
} else {
        print "VERBOSE \"Asterisk::AGI NOT INSTALLED - see documentation\" 0\n";
        exit;
}
if (eval "require Net::Telnet;") {
        use Net::Telnet;
} else {
        print "VERBOSE \"Net::Telnet NOT INSTALLED - see documentation\" 0\n";
        exit;
}

my $debug = 2;

my %ext;     # Hash that will contain our list of extensions to call
my %ext_hunt;# Hash that will contain our list of extensions to call used by huntgroup
my $cidnum;  # Caller ID Number for this call
my $cidname; # Caller ID Name for this call
my $timer;   # Call timer for Dial command
my $dialopts;# options for dialing
my $rc;      # Catch return code
my $priority;# Next priority 
my $rgmethod;# If Ring Group what ringing method was chosen
my %config;  # Contents of /etc/amportal.conf

my $AGI = new Asterisk::AGI;
my %input = $AGI->ReadParse();
$AGI->setcallback(\&mycallback);

if ($debug >= 2) {
  foreach $key (keys %input) {
    debug("$key = " . $input{$key},3);
  }
}
$priority = $input{'priority'} + 1;

if ($input{'callerid'} =~  /^\"(.*)\"\s+\<(\d+)-?(\d*)\>\s*$/) {
  $cidname = $1;
  $cidnum  = $2.$3;
  debug("Caller ID name is '$cidname' number is '$cidnum'", 1);
} elsif ($input{'callerid'} =~  /^(\d+)*$/) {
  $cidname = $1;
  $cidnum  = $1;
  debug("Caller ID name and number are '$cidnum'", 1);
} else {
  $cidname = undef;
  $cidnum  = undef;
  debug("Caller ID is not set", 1);
}

$timer = $AGI->get_variable('ARG1') || 0;
$dialopts = $AGI->get_variable('ARG2') || '';
$rgmethod = $AGI->get_variable("RingGroupMethod") || 'none';
debug("Methodology of ring is  '$rgmethod'", 1);

# Start with Arg Count set to 3 as two args are used
my $arg_cnt = 3;
while(my $arg = $AGI->get_variable('ARG' . $arg_cnt)) {
  if ($arg == 'noresponse') {  #not sure why, dialparties will get stuck in a loop if noresponse
  	debug("get_variable got a \"noresponse\"!  Exiting",3);
  	exit($arg_cnt);
  }
  @extarray=split(/-/,$arg);
  foreach my $k (@extarray) {
    $ext{$k} = $k;
    debug("Added extension $k to extension map", 3);
  }
  
  $arg_cnt++;
}

# Check for call forwarding first
# If call forward is enabled, we use chan_local
foreach my $k (keys %ext) {
  my $cf  = $AGI->database_get('CF',$k);
  if ($cf) {
    $ext{$k} = $cf.'#';  # append a hash sign so we can send out on chan_local below.
    debug("Extension $k has call forward set to $cf", 1);
  } else {
    debug("Extension $k cf is disabled", 3);
  }
}

# Now check for DND
foreach my $k (keys %ext) {
	if (($ext{$k} =~ /\#/)!=1) {   #no point in doing if cf is enabled
		my $dnd = $AGI->database_get('DND',$ext{$k});
		if ($dnd) {
			debug("Extension $ext{$k} has do not disturb enabled", 1);
			delete $ext{$k};
		} else {
			debug("Extension $ext{$k} do not disturb is disabled", 3);
		}
	}
}

# Main calling loop

my $ds = '';

foreach my $k (keys %ext) {
  my $extnum = $ext{$k};
  my $exthascw = ($AGI->database_get('CW', $extnum)) ? 1 : 0;
  my $extcfb = $AGI->database_get('CFB', $extnum);
  my $exthascfb = (length($extcfb) > 0) ? 1 : 0;

  # Dump details in level 4
  debug("extnum: $extnum",4);
  debug("exthascw: $exthascw",4);
  debug("exthascfb: $exthascfb",4);
  debug("extcfb: $extcfb",4);

  # if CF is not in use; AND
  # CW is not in use or CFB is in use on this extension, then we need to check!
  if (($ext{$k} =~ /\#/)!=1 && (($exthascw == 0) || ($exthascfb == 1))) {
    debug("Checking CW and CFB status for extension $extnum",3);
    my $extstate = is_ext_avail($extnum);
    debug("extstate: $extstate",4);

    if ($extstate > 0) { # extension in use
      debug("Extension $extnum is not available to be called",1);

      if ($exthascfb == 1) { # CFB is in use
        debug("Extension $extnum has call forward on busy set to $extcfb",1);

        $extnum = $extcfb . '#';   # same method as the normal cf, i.e. send to Local
      } elsif ($exthascw == 0) { # CW not in use
        debug("Extension $extnum has call waiting disabled",1);
        $extnum = '';
      } else {
        # no reason why this will ever happen! but kept in for clarity
        debug("Extension $extnum has call waiting enabled",1);
      }
    } elsif ($extstate < 0) { # -1 means couldn't read status or chan unavailable
      debug("ExtensionState for $extnum could not be read...assuming ok",3);
    } else {
      debug("Extension $extnum is available...skipping checks",1);
    }
  } elsif ($exthascw == 1) { # just log the fact that CW enabled
    debug("Extension $extnum has call waiting enabled",1);
  }

if ($extnum != '') 
{ # Still got an extension to be called?
	my $extds = get_dial_string($extnum);
    	$ds .= $extds . '&';

    	# Update Caller ID for calltrace application
    	if (($ext{$k} =~ /#/)!=1 && ($rgmethod ne "hunt") && ($rgmethod ne "memoryhunt")) {   	
      		if ($cidnum) {
        		$rc = $AGI->database_put('CALLTRACE', $ext{$k}, $cidnum);
        		if ($rc == 1) {
          			debug("DbSet CALLTRACE/$ext{$k} to $cidnum", 3);
        		} else {
          			debug("Failed to DbSet CALLTRACE/$ext{$k} to $cidnum ($rc)", 1);
        		}
      		} else {
        		# We don't care about retval, this key may not exist
        		$AGI->database_del('CALLTRACE', $ext{$k});
        		debug("DbDel CALLTRACE/$ext{$k} - Caller ID is not defined", 3);
      		}
    	} else{
		$ext_hunt{$k}=$extds; # Need to have the extension HASH set with technology for hunt group ring 
	}
}
}
my $dshunt ='';
my $loops=0;
my $myhuntmember="";
if (($rgmethod eq "hunt") || ($rgmethod eq "memoryhunt")) {
        $AGI->set_variable(CALLTRACE_HUNT,$cidnum) if ($cidnum); 
        foreach my $k (@extarray) { # we loop through the original array to get the extensions in order of importance
                if ($ext_hunt{$k}) {#If the original array is included in the extension hash then set variables
                        $myhuntmember="HuntMember"."$loops";
                        if ($rgmethod eq "hunt") {
                                $AGI->set_variable($myhuntmember,$ext_hunt{$k});
                        } elsif ($rgmethod eq "memoryhunt") {
                                if ($loops==0) {
                                        $dshunt =$ext_hunt{$k};
                                } else {
                                        $dshunt .='&'.$ext_hunt{$k};
                                }
                                $AGI->set_variable($myhuntmember,$dshunt);
                        }
                        $loops+=1;
                }
        }
}

chop $ds if length($ds);

if (!length($ds)) {
  $AGI->exec('NoOp');
} else {
	if (($rgmethod eq "hunt") || ($rgmethod eq "memoryhunt")){
                $ds = '|';
                $ds .= $timer if ($timer);
                $ds .= '|' . $dialopts; # pound to transfer, provide ringing
                $AGI->set_variable('ds',$ds);
                $AGI->set_variable("HuntMembers",$loops);
                $AGI->set_priority(20); #dial command is at priority 20 where dialplan handles calling a ringgroup with strategy of "hunt" or "MemoryHunt"
        } else{
                $ds .= '|';
                $ds .= $timer if ($timer);
                $ds .= '|' . $dialopts; # pound to transfer, provide ringing
                $AGI->set_variable('ds',$ds);
                $AGI->set_priority(10); #dial command is at priority 10
        }
}

exit 0;

sub get_dial_string
{
  my $extnum = shift;

  my $dialstring = '';

  if ($extnum =~ s/#//) {                       # "#" used to identify external numbers in forwards and callgourps
    $dialstring = 'Local/'.$extnum.'@from-internal';
  } else {
    $device = $AGI->database_get('AMPUSER',$extnum.'/device');
    # a user can be logged into multipe devices, append the dial string for each
    @device_array=split('&',$device);
    foreach $adevice (@device_array) {
    	$dialstring .= $AGI->database_get('DEVICE',$adevice.'/dial');
    	$dialstring .= '&';
    }
    chop($dialstring);
    return $dialstring;
  }
}

sub debug
{
  my $string = shift;
  my $level = shift || 0;

  if ($debug) {
    $AGI->verbose($string, $level);
  }
  return(0);
}

sub mycallback
{
  my $rc = shift;
  debug("User hung up. (rc=" . $rc . ")", 1);
  exit ($rc)
}

sub is_ext_avail{  #uses manager api to get ExtensionState info

        $server_ip='127.0.0.1';

        my $extnum = shift;

        $tn = new Net::Telnet (Port => 5038,
                                Prompt => '/.*[\$%#>] $/',
                                Output_record_separator => '',
                                Errmode    => 'return'
                                );

		# Load %config with /etc/amportal.conf..
		&get_amportal_conf;
        #connect to manager and login
        $tn->open("$server_ip");
        $tn->waitfor('/0\n$/');
		$tn->print("Action: Login\n");
		$tn->print("Username: ".$config{"AMPMGRUSER"}."\n");
		$tn->print("Secret: ".$config{"AMPMGRPASS"}."\n\n");
		my ($pm, $m) = $tn->waitfor('/Authentication (.+)\n\n/');
		if ($m =~ /Authentication failed/) {
			   debug ("/etc/amportal.conf contains incorrect AMPMGRUSER or AMPMGRPASS");
			   exit;
		}
		debug ("Correct AMPMGRUSER and AMPMGRPASS", 3);
        #issue command
        $tn->print("Action: ExtensionState\nExten: $extnum\nContext: ext-local\nActionId: 8355\n\n");
        $tn->waitfor('/Response: Success\n/');
        $tn->waitfor('/ActionID: 8355\n/');

        #wait for status
        my $ok = 0; # 0 means ok to call
	my $extstatus = 0;
        ($ok, $extstatus) = $tn->waitfor('/Status: .*\n/') or die "Could not get ExtensionState";

        #logoff
        $tn->print("Action: Logoff\n\n");

	if ($ok && $extstatus =~ /Status: (.*)/) {
		$extstatus = $1;
        } else {
		$extstatus = -1;	# Make -1 if couldn't read correctly
	}

        return $extstatus;
}

sub get_amportal_conf {
       # If this is likely to change, we might need to put this as a 
       # variable at the top
       my $amportal_conf = "/etc/amportal.conf"; 
       if (open (FH, $amportal_conf)) {
               while (my $tmp = <FH>) {
               # Useful regexp taken from Julien Blache's SF patch nbr
               # 1234233 -  Thanks!
               if ($tmp =~ /^\s*([a-zA-Z0-9]+)\s*=\s*(.*)\s*([;#].*)?/) {
                       # This is a global..
                       $config{$1} = $2;
                       }
               }
       } else {
               debug ("Unable to open $amportal_conf");
       }
}

